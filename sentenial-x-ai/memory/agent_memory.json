import os
import json
from datetime import datetime

# NOTE: Using the same file path constant for consistency
MEMORY_FILE = "memory/agent_memory.json"

def get_successful_findings(finding_keywords=None):
    """
    Reads the agent memory log and filters entries based on a list of keywords.

    Args:
        finding_keywords (list, optional): A list of strings (e.g., ['Found', 'Success', 'Hit'])
                                           to look for in the 'event' text. 
                                           Defaults to common success indicators if None.

    Returns:
        list: A list of dictionaries containing only the events that match the keywords.
    """
    if finding_keywords is None:
        finding_keywords = ['Found', 'Success', 'Vulnerability', 'Hit', 'Credentials']

    # 1. Check if file exists before attempting to read
    if not os.path.exists(MEMORY_FILE):
        print(f"Error: Memory file not found at {MEMORY_FILE}")
        return []

    try:
        # 2. Load all memory entries
        with open(MEMORY_FILE, "r") as f:
            all_memory = json.load(f)
            
        # 3. Filter using list comprehension and keyword check
        successful_findings = [
            entry for entry in all_memory 
            if any(keyword.lower() in str(entry.get("event", "")).lower() for keyword in finding_keywords)
        ]
        
        return successful_findings
        
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from {MEMORY_FILE}. File may be corrupt.")
        return []
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return []

# --- Example Usage ---
# successful_results = get_successful_findings()
# for finding in successful_results:
#     print(f"[{finding['timestamp'][:19]}] HIT: {finding['event']}")

{
  "metadata": {
    "version": "1.0.0",
    "last_updated": "2025-09-09T00:00:00Z",
    "description": "Persistent agent memory for Sentenial-X AI multi-agent system"
  },
  "agents": {
    "sentinel_core": {
      "id": "agent-001",
      "role": "threat_defense",
      "policies": ["PPO", "DQN"],
      "last_action": "blocked_suspicious_connection",
      "experience_buffer": [
        {
          "state": "incoming_traffic_high",
          "action": "block_ip",
          "reward": 0.85,
          "timestamp": "2025-09-08T12:45:22Z"
        },
        {
          "state": "normal_traffic",
          "action": "monitor",
          "reward": 0.10,
          "timestamp": "2025-09-08T12:50:00Z"
        }
      ]
    },
    "sentinel_analyzer": {
      "id": "agent-002",
      "role": "semantic_analysis",
      "policies": ["A3C"],
      "last_action": "flagged_prompt_injection",
      "experience_buffer": [
        {
          "state": "user_prompt_detected",
          "action": "analyze",
          "reward": 0.75,
          "timestamp": "2025-09-08T13:05:11Z"
        }
      ]
    }
  },
  "telemetry": {
    "system_health": {
      "cpu_usage": "32%",
      "memory_usage": "2.4GB",
      "disk_usage": "45%",
      "uptime": "3h 12m"
    },
    "network": {
      "active_connections": 47,
      "threats_detected": 3,
      "blocked_ips": ["192.168.1.24", "203.0.113.88"]
    }
  }
}

MEMORY_FILE = "memory/agent_memory.json"

def remember(event):
    os.makedirs("memory", exist_ok=True)
    memory = []
    if os.path.exists(MEMORY_FILE):
        with open(MEMORY_FILE, "r") as f:
            memory = json.load(f)
    memory.append({
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "event": event
    })
    with open(MEMORY_FILE, "w") as f:
        json.dump(memory, f, indent=2)
