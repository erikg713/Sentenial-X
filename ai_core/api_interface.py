# ai_core/api_interface.py
"""
API interface for Sentenial-X AI core.

Improvements:
- Use Pydantic models for request validation.
- Stronger typing and explicit error handling.
- Timeout handling for long-running tasks.
- Structured logging for observability.
- Clear route metadata for automatic docs.
"""
from typing import Any, Dict, Optional
import asyncio
import logging

from fastapi import APIRouter, Body, HTTPException, status
from pydantic import BaseModel, Field, validator

from .wormgpt_detector import classify_wormgpt
from .attack_simulator import simulate_attack
from .threat_analyzer import analyze_threat

# Router instance
router = APIRouter(prefix="/api", tags=["ai_core"])

# Logger
logger = logging.getLogger("sentenial.ai_core.api_interface")

# Tunable timeout for upstream processing functions (seconds)
DEFAULT_TASK_TIMEOUT = 30.0

# Allowed complexity values for analyze_threat
_ALLOWED_COMPLEXITIES = {"low", "medium", "high"}


class AnalyzeRequest(BaseModel):
    text: str = Field(..., min_length=1, description="Text to analyze")
    complexity: str = Field(
        "medium",
        description="Analysis complexity level: one of 'low', 'medium', 'high'",
    )

    @validator("complexity")
    def complexity_must_be_known(cls, v: str) -> str:
        v_lower = v.lower()
        if v_lower not in _ALLOWED_COMPLEXITIES:
            raise ValueError(f"complexity must be one of {_ALLOWED_COMPLEXITIES}")
        return v_lower


class TextRequest(BaseModel):
    text: str = Field(..., min_length=1, description="Text payload")


async def _call_with_timeout(coro, timeout: Optional[float] = DEFAULT_TASK_TIMEOUT) -> Any:
    """
    Await a coroutine with a timeout and translate common errors into HTTPExceptions.
    """
    try:
        return await asyncio.wait_for(coro, timeout=timeout)
    except asyncio.TimeoutError as e:
        logger.warning("Operation timed out after %.1fs", timeout)
        raise HTTPException(
            status_code=status.HTTP_504_GATEWAY_TIMEOUT,
            detail="Processing timed out. Try again with a smaller input or increase timeout.",
        ) from e
    except HTTPException:
        # Re-raise HTTPExceptions unchanged (so internal functions can raise them)
        raise
    except ValueError as e:
        # Map ValueError from internal validation to 400
        logger.debug("Validation error from internal call: %s", e)
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e)) from e
    except Exception as e:
        # Catch-all for unexpected errors: log and return 500
        logger.exception("Unexpected error while processing request: %s", e)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error while processing the request.",
        ) from e


@router.post(
    "/analyze_threat",
    summary="Analyze text for potential threats",
    response_model=Dict[str, Any],
    status_code=status.HTTP_200_OK,
)
async def api_analyze_threat(payload: AnalyzeRequest = Body(...)) -> Dict[str, Any]:
    """
    Analyze the provided text for threats.

    Uses the 'complexity' field to adjust analysis depth. Returns the analyzer's result
    as a JSON-compatible mapping.
    """
    logger.info("Received analyze_threat request (len=%d, complexity=%s)", len(payload.text), payload.complexity)
    result = await _call_with_timeout(analyze_threat(payload.text, payload.complexity))
    return result


@router.post(
    "/classify_wormgpt",
    summary="Classify whether text was generated by WormGPT",
    response_model=Dict[str, Any],
    status_code=status.HTTP_200_OK,
)
async def api_classify_wormgpt(payload: TextRequest = Body(...)) -> Dict[str, Any]:
    """
    Classify text as WormGPT-generated or not.

    Returns a structured dict with fields such as 'is_wormgpt' and optional 'confidence'.
    """
    logger.info("Received classify_wormgpt request (len=%d)", len(payload.text))
    result = await _call_with_timeout(classify_wormgpt(payload.text))
    return result


@router.post(
    "/simulate_attack",
    summary="Simulate an attack based on provided text",
    response_model=Dict[str, Any],
    status_code=status.HTTP_200_OK,
)
async def api_simulate_attack(payload: TextRequest = Body(...)) -> Dict[str, Any]:
    """
    Simulate an attack scenario driven by the given text payload.

    This endpoint is designed for defensive testing and returns a simulation report.
    """
    logger.info("Received simulate_attack request (len=%d)", len(payload.text))
    result = await _call_with_timeout(simulate_attack(payload.text))
    return result
