# api/controllers/exploits_controller.py

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from api import models, schemas
from api.database import get_db
from api.utils.logger import get_logger

logger = get_logger(__name__)
router = APIRouter(prefix="/exploits", tags=["Exploits"])


@router.get("/", response_model=List[schemas.Exploit])
def list_exploits(db: Session = Depends(get_db)):
    """
    Retrieve all registered exploit modules.
    """
    exploits = db.query(models.Exploit).all()
    logger.info("Fetched all exploits", extra={"count": len(exploits)})
    return exploits


@router.get("/{exploit_id}", response_model=schemas.Exploit)
def get_exploit(exploit_id: int, db: Session = Depends(get_db)):
    """
    Get details of a specific exploit by ID.
    """
    exploit = db.query(models.Exploit).filter(models.Exploit.id == exploit_id).first()
    if not exploit:
        logger.warning("Exploit not found", extra={"exploit_id": exploit_id})
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Exploit with ID {exploit_id} not found."
        )
    return exploit


@router.post("/", response_model=schemas.Exploit, status_code=status.HTTP_201_CREATED)
def create_exploit(exploit: schemas.ExploitCreate, db: Session = Depends(get_db)):
    """
    Register a new exploit in the system.
    """
    db_exploit = models.Exploit(**exploit.dict())
    db.add(db_exploit)
    db.commit()
    db.refresh(db_exploit)
    logger.info("Exploit registered", extra={"exploit_id": db_exploit.id})
    return db_exploit


@router.put("/{exploit_id}", response_model=schemas.Exploit)
def update_exploit(exploit_id: int, exploit: schemas.ExploitUpdate, db: Session = Depends(get_db)):
    """
    Update exploit details.
    """
    db_exploit = db.query(models.Exploit).filter(models.Exploit.id == exploit_id).first()
    if not db_exploit:
        logger.warning("Attempted update on missing exploit", extra={"exploit_id": exploit_id})
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Exploit with ID {exploit_id} not found."
        )

    for key, value in exploit.dict(exclude_unset=True).items():
        setattr(db_exploit, key, value)

    db.commit()
    db.refresh(db_exploit)
    logger.info("Exploit updated", extra={"exploit_id": exploit_id})
    return db_exploit


@router.delete("/{exploit_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_exploit(exploit_id: int, db: Session = Depends(get_db)):
    """
    Remove an exploit from the system.
    """
    db_exploit = db.query(models.Exploit).filter(models.Exploit.id == exploit_id).first()
    if not db_exploit:
        logger.warning("Attempted delete on missing exploit", extra={"exploit_id": exploit_id})
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Exploit with ID {exploit_id} not found."
        )

    db.delete(db_exploit)
    db.commit()
    logger.info("Exploit deleted", extra={"exploit_id": exploit_id})
    return None


@router.post("/{exploit_id}/execute")
def execute_exploit(exploit_id: int, db: Session = Depends(get_db)):
    """
    Trigger execution of a specific exploit.
    (Stub for integration with exploit simulation engine)
    """
    exploit = db.query(models.Exploit).filter(models.Exploit.id == exploit_id).first()
    if not exploit:
        logger.warning("Attempted execution on missing exploit", extra={"exploit_id": exploit_id})
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Exploit with ID {exploit_id} not found."
        )

    # ðŸ”¥ Hook into Sentenial-X Exploit Engine here
    logger.info("Exploit executed", extra={"exploit_id": exploit_id, "name": exploit.name})
    return {"status": "success", "message": f"Exploit {exploit.name} executed successfully."}
