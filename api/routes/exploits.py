# routes/exploits.py
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from utils.response import success_response, error_response
from modules.exploits import exploit_registry

router = APIRouter(prefix="/api/exploits", tags=["Exploits"])

class ExploitRequest(BaseModel):
    target: str
    options: dict = {}

@router.get("/")
async def list_exploits():
    """
    List all available exploit modules.
    """
    try:
        exploits = [{"name": name, "description": mod.description} for name, mod in exploit_registry.items()]
        return success_response("Available exploits fetched.", exploits)
    except Exception as e:
        return error_response(f"Failed to fetch exploits: {str(e)}", 500)

@router.post("/{exploit_name}/run")
async def run_exploit(exploit_name: str, request: ExploitRequest):
    """
    Run a specific exploit against a target.
    """
    if exploit_name not in exploit_registry:
        raise HTTPException(status_code=404, detail=f"Exploit '{exploit_name}' not found.")

    exploit = exploit_registry[exploit_name]
    try:
        result = exploit.run(request.target, request.options)
        return success_response(f"Exploit {exploit_name} executed successfully.", result)
    except Exception as e:
        return error_response(f"Exploit {exploit_name} execution failed: {str(e)}", 500)

@router.get("/{exploit_name}")
async def get_exploit_details(exploit_name: str):
    """
    Get metadata/details about a specific exploit.
    """
    if exploit_name not in exploit_registry:
        raise HTTPException(status_code=404, detail=f"Exploit '{exploit_name}' not found.")

    exploit = exploit_registry[exploit_name]
    details = {
        "name": exploit_name,
        "description": exploit.description,
        "options": exploit.options
    }
    return success_response(f"Exploit {exploit_name} details fetched.", details) 