import subprocess
import threading
import logging
import queue
from typing import Optional, Dict, Any, List
from concurrent.futures import ThreadPoolExecutor, Future

logger = logging.getLogger("ExploitRunner")
logging.basicConfig(level=logging.INFO)


class ExploitExecutionError(Exception):
    pass


class ExploitRunner:
    def __init__(self, max_workers: int = 5, timeout: int = 60):
        """
        Initialize the ExploitRunner.

        Args:
            max_workers (int): Max concurrent exploit scripts.
            timeout (int): Timeout in seconds for each exploit.
        """
        self.max_workers = max_workers
        self.timeout = timeout
        self.executor = ThreadPoolExecutor(max_workers=self.max_workers)
        self.futures: List[Future] = []

    def run_exploit(self, command: List[str]) -> Dict[str, Any]:
        """
        Run a single exploit script command synchronously with timeout.

        Args:
            command (List[str]): Command line list for subprocess.

        Returns:
            Dict[str, Any]: Dictionary with keys: 'success', 'stdout', 'stderr', 'returncode'
        """
        logger.info(f"Running exploit command: {' '.join(command)}")

        try:
            completed = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=self.timeout,
                check=False,
            )
            success = completed.returncode == 0
            logger.info(f"Exploit finished with return code {completed.returncode}")
            return {
                "success": success,
                "stdout": completed.stdout,
                "stderr": completed.stderr,
                "returncode": completed.returncode,
            }
        except subprocess.TimeoutExpired:
            logger.error(f"Exploit timed out after {self.timeout} seconds: {' '.join(command)}")
            raise ExploitExecutionError("Timeout expired")
        except Exception as e:
            logger.error(f"Error running exploit: {e}")
            raise ExploitExecutionError(str(e))

    def submit_exploit(self, command: List[str]) -> Future:
        """
        Submit an exploit command for asynchronous execution.

        Args:
            command (List[str]): Command line list.

        Returns:
            Future: Future object representing the async execution.
        """
        future = self.executor.submit(self.run_exploit, command)
        self.futures.append(future)
        return future

    def wait_all(self) -> List[Dict[str, Any]]:
        """
        Wait for all submitted exploits to complete.

        Returns:
            List[Dict[str, Any]]: Results from each exploit execution.
        """
        results = []
        for future in self.futures:
            try:
                result = future.result()
                results.append(result)
            except ExploitExecutionError as e:
                results.append({"success": False, "error": str(e)})
            except Exception as e:
                results.append({"success": False, "error": f"Unexpected error: {e}"})
        self.futures.clear()
        return results

    def shutdown(self):
        """
        Shutdown the executor cleanly.
        """
        self.executor.shutdown(wait=True)
        logger.info("ExploitRunner shutdown completed.")


# Example usage (standalone testing)
if __name__ == "__main__":
    runner = ExploitRunner(max_workers=3, timeout=30)

    cmds = [
        ["python3", "-c", "print('Exploit 1 running'); import time; time.sleep(2)"],
        ["python3", "-c", "print('Exploit 2 running'); import time; time.sleep(1)"],
        ["python3", "-c", "import time; time.sleep(35)"],  # This one will timeout
    ]

    futures = [runner.submit_exploit(cmd) for cmd in cmds]
    results = runner.wait_all()

    for i, res in enumerate(results):
        print(f"Exploit {i+1} result: {res}")

    runner.shutdown()
