import socket
import logging
from typing import List, Dict, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed

logger = logging.getLogger("PortScanner")

def scan_target(target: str) -> dict:
    # Mock vulnerability scan (safe, no real exploits)
    return {"target": target, "vulnerabilities": ["Mock SQL injection vulnerability found (simulation only)"]}

class PortScanner:
    def __init__(self, timeout: float = 1.0, max_workers: int = 100, retries: int = 1):
        """
        Initialize the port scanner.

        Args:
            timeout (float): Timeout in seconds for socket connection.
            max_workers (int): Maximum threads for parallel scanning.
            retries (int): Number of retries per port.
        """
        self.timeout = timeout
        self.max_workers = max_workers
        self.retries = retries

    def _scan_port(self, host: str, port: int) -> Tuple[int, bool]:
        """
        Attempt to connect to a port on a host.

        Args:
            host (str): Target IP or hostname.
            port (int): Port number.

        Returns:
            Tuple[int, bool]: Port and status (True=open, False=closed).
        """
        for attempt in range(self.retries):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                    sock.settimeout(self.timeout)
                    result = sock.connect_ex((host, port))
                    if result == 0:
                        return port, True
            except Exception as e:
                logger.debug(f"Error scanning {host}:{port} attempt {attempt + 1}: {e}")
        return port, False

    def scan_ports(self, host: str, ports: List[int]) -> Dict[int, bool]:
        """
        Scan a list of ports on a host.

        Args:
            host (str): Target host.
            ports (List[int]): Ports to scan.

        Returns:
            Dict[int, bool]: Mapping of port to open status.
        """
        results = {}
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            future_to_port = {executor.submit(self._scan_port, host, port): port for port in ports}
            for future in as_completed(future_to_port):
                port, is_open = future.result()
                results[port] = is_open
                logger.debug(f"Port {port} on {host} is {'open' if is_open else 'closed'}")
        return results


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Simple Port Scanner")
    parser.add_argument("host", help="Target hostname or IP")
    parser.add_argument(
        "--ports",
        type=str,
        default="22,80,443,8080",
        help="Comma-separated list of ports to scan (default: 22,80,443,8080)",
    )
    parser.add_argument("--timeout", type=float, default=1.0, help="Socket timeout in seconds")
    parser.add_argument("--retries", type=int, default=1, help="Retries per port")
    args = parser.parse_args()

    ports_to_scan = [int(p.strip()) for p in args.ports.split(",") if p.strip().isdigit()]
    scanner = PortScanner(timeout=args.timeout, retries=args.retries)

    print(f"Scanning {args.host} on ports: {ports_to_scan}")
    scan_results = scanner.scan_ports(args.host, ports_to_scan)

    for port, open_status in sorted(scan_results.items()):
        status = "OPEN" if open_status else "closed"
        print(f"Port {port}: {status}")
